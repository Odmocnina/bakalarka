package core.model.cellular;

import app.AppContext;
import core.model.CarParams;
import core.model.Direction;
import core.model.Road;
import core.sim.Simulation;
import core.utils.Constants;
import core.utils.MyLogger;
import core.utils.RequestConstants;
import core.utils.StringEditor;

import java.util.HashMap;
import java.util.LinkedList;

/*****************************
 * CellularRoad class representing a road using cellular automaton model, extends Road class
 *
 * @author Michael Hladky
 * @version 1.0
 *******************************/
public class CellularRoad extends Road {

    /** 2D array representing lanes and positions **/
    private Cell[][] cells;

    /** number of cells in straight lane (length of the road in cells **/
    private int numberOfCells;

    /** size of each cell in meters, used to translate length given in config to length in cells **/
    private double cellSize;

    /**
     * Constructor for CellularRoad, creates the road and initializes cells, and other parameters, like cell size
     *
     * @param length length of the road in meters
     * @param numberOfLanes number of lanes on the road
     * @param speedLimit speed limit on the road in m/s
     * @param cellSize size of each cell in meters
     **/
    public CellularRoad(double length, int numberOfLanes, double speedLimit, double cellSize) {
        super(length, numberOfLanes, speedLimit, Constants.CELLULAR);
        this.cellSize = cellSize;
        createRoad();
    }

    /**
     * Creates the road by initializing the cells array based on the length and number of lanes and length
     **/
    private void createRoad() {
        this.numberOfCells = (int) Math.ceil(length / this.cellSize);
        cells = new Cell[numberOfLanes][numberOfCells];
        for (int lane = 0; lane < numberOfLanes; lane++) {
            for (int position = 0; position < numberOfCells; position++) {
                cells[lane][position] = new Cell();
            }
        }

        // first test of occupied cells, DELETE LATER
        cells[0][5].setOccupied(true);
        CarParams carParams = new CarParams();
        carParams.setParameter(RequestConstants.CURRENT_SPEED_REQUEST, 0);
        carParams.setParameter(RequestConstants.MAX_SPEED_REQUEST, 1.0);
        carParams.xPosition = 5;
        carParams.lane = 0;
        carParams.setParameter(RequestConstants.LENGTH_REQUEST, 1);
        carParams.color = Constants.CAR_COLORS[0];
        cells[0][5].setCarParams(carParams);
        cells[0][5].setHead(true);

        cells[0][0].setOccupied(true);
        cells[0][1].setOccupied(true);
        carParams = new CarParams();
        carParams.setParameter(RequestConstants.CURRENT_SPEED_REQUEST, 0);
        carParams.setParameter(RequestConstants.MAX_SPEED_REQUEST, 1.0);
        carParams.xPosition = 1;
        carParams.lane = 0;
        carParams.setParameter(RequestConstants.LENGTH_REQUEST, 2);
        carParams.color = Constants.CAR_COLORS[0];
        cells[0][1].setCarParams(carParams);
        cells[0][1].setHead(true);

    }

    /**
     * function to check if it is ok to put a car at the beginning of the lane, i.e., if there is enough space for the
     * car, if it isn't blocked by other cars already on the road
     *
     * @param car CarParams of the car to be placed
     * @param lane lane number where the car is to be placed
     * @return true if it is ok to place the car, false otherwise
     **/
    private boolean isOkToPutCar(CarParams car, int lane) {
        for (int i = 0; i <= car.getParameter(RequestConstants.LENGTH_REQUEST) + 1; i++) {
            if (i >= numberOfCells || cells[lane][i].isOccupied()) {
                return false;
            }
        }

        return true;
    }

    /**
     * function to add a car from the queue to the road at the beginning of the lane, if adding from queue is enabled,
     * instead of normal generation
     *
     * @param lane lane number where the car is to be placed
     **/
    private void addFromQueue(int lane) {
        CarParams cp = super.carQueuesPerLane[lane].peek();

        if (cp != null && this.isOkToPutCar(cp, lane)) {
            placeCar(cp, (int) (cp.getParameter(RequestConstants.LENGTH_REQUEST) - 1), lane);
            super.carQueuesPerLane[lane].poll();
        }
    }

    /**
     * function to add a car generated by the generator to the road at the beginning of the lane
     *
     * @param lane lane number where the car is to be placed
     **/
    private void addFromGenerator(int lane) {
        if (super.generator.decideIfNewCar()) {
            CarParams newCar = super.generator.generateCar();

            if (this.isOkToPutCar(newCar, lane)) {
                placeCar(newCar, (int) (newCar.getParameter(RequestConstants.LENGTH_REQUEST) - 1), lane);
            }
        }
    }

    /**
     * function to try to add cars to each lane, either from the queue or from the generator, trying each lane in order
     **/
    private void tryToAddCar() {
        for (int lane = 0; lane < numberOfLanes; lane++) {
            if (super.generator.generatingToQueue()) {
                this.addFromQueue(lane);
            } else {
                this.addFromGenerator(lane);
            }
        }
    }

    /**
     * function to find all cars that want to change lanes and return a list of lane change results, cars that were
     * marked to change lanes are not changed yet, that is done in a separate function to avoid conflicts
     *
     * @return LinkedList of LaneChangeResult objects representing cars that want to change lanes
     **/
    private LinkedList<LaneChangeResult> findLaneChanges() {
        LinkedList<LaneChangeResult> changedCars = new LinkedList<>();

        for (int position = this.numberOfCells - 1; position >= 0; position--) {
            for (int lane = numberOfLanes - 1; lane >= 0; lane--) {
                if (cells[lane][position].isOccupied() && cells[lane][position].isHead()) {
                    Direction laneChangeResult = attemptLaneChange(cells[lane][position]);
                    if (laneChangeResult != Direction.STRAIGHT) {
                        LaneChangeResult lcr = new LaneChangeResult(laneChangeResult, cells[lane][position].getCarParams());
                        changedCars.add(lcr);
                    }
                }
            }
        }

        return changedCars;
    }

    /**
     * function to process lane changes for cars that were marked to change lanes, actually changing their lanes
     *
     * @param changedCars LinkedList of LaneChangeResult objects representing cars that want to change lanes
     **/
    private void processLaneChanges(LinkedList<LaneChangeResult> changedCars) {
        for (LaneChangeResult lcr : changedCars) {
            Direction direction = lcr.direction;
            CarParams carParams = lcr.carParams;
            if (direction == Direction.LEFT && AppContext.SIMULATION.getStepCount() % 2 == 0) {
                int currentLane = carParams.lane;
                if (currentLane > 0) {
                    int targetLane = currentLane - 1;
                    carParams.lane = targetLane;
                    this.placeCar(carParams, (int) carParams.xPosition, targetLane);
                    this.removeCar(currentLane, (int) carParams.xPosition);
                }
            } else if (direction == Direction.RIGHT && AppContext.SIMULATION.getStepCount() % 2 == 1) {
                int currentLane = carParams.lane;
                if (currentLane < numberOfLanes - 1) {
                    int targetLane = currentLane + 1;
                    carParams.lane = targetLane;
                    this.placeCar(carParams, (int) carParams.xPosition, targetLane);
                    this.removeCar(currentLane, (int) carParams.xPosition);
                }
            }
        }
    }

    /**
     * function to perform lane change step, finding cars that want to change lanes and processing their lane changes
     **/
    private void laneChangeStep() {
        LinkedList<LaneChangeResult> changedCars = findLaneChanges();
        this.processLaneChanges(changedCars);
    }

    /**
     * function to perform forward step, updating the positions of all cars on the road-based on their speeds
     *
     * @return number of cars that have passed the end of the road
     **/
    private int forwardStep() {
        int carsPassed = 0;
        for (int position = this.numberOfCells - 1; position >= 0; position--) {
            for (int lane = numberOfLanes - 1; lane >= 0; lane--) {
                if (cells[lane][position].isOccupied() && cells[lane][position].isHead()) {
                    String requestParameters = AppContext.CAR_FOLLOWING_MODEL.requestParameters();
                    HashMap<String, Double> parameters = getParameters(lane, position, requestParameters);

                    if (parameters == null) { // this would be very fucked up if it happened
                        MyLogger.log("Error getting parameters for car at lane " + lane + ", position "
                                        + position, Constants.ERROR_FOR_LOGGING);
                        continue;
                    }

                    double newSpeed = AppContext.CAR_FOLLOWING_MODEL.getNewSpeed(parameters);

                    if (isCarAtEnd(cells[lane][position].getCarParams(), (int) newSpeed)) {
                        if (checkIfCarStillRelevant(cells[lane][position].getCarParams(), (int) newSpeed)) {
                            moveCarHead(cells[lane][position].getCarParams(), (int) newSpeed);
                        } else {
                            carsPassed++;
                        }
                        //removeCar(lane, position); //easier and probably better solution, if car touches the end
                        //delete it whole but im a retard and keep trying to make that only
                        //part that is outside will delete, viz voodoo at top, fucking thing
                    } else {
                        cells[lane][position].getCarParams().setParameter(RequestConstants.CURRENT_SPEED_REQUEST
                                , newSpeed);
                        this.moveCar(cells[lane][position]);
                    }
                }
            }
        }

        return carsPassed;
    }

    /**
     * update position of the cars on road
     *
     * @return int number of cars that have passed the entire road
     **/
    @Override
    public int updateRoad() {
        this.laneChangeStep();
        int carsPassed = this.forwardStep();

        if (true)
            this.tryToAddCar(); // Attempt to add a new car at the beginning of each lane
        return carsPassed;
    }

    /**
     * move car form old position to new position depending on its current speed
     *
     * @param cell Cell representing the head of the car to be moved, head contains the CarParams, including speed,
     *             length and other parameters needed for movement
     **/
    private void moveCar(Cell cell) {
        if (cell == null || !cell.isOccupied() || !cell.isHead()) {
            MyLogger.log("Cannot move car: cell is null, unoccupied, or not head", Constants.DEBUG_FOR_LOGGING);
            return;
        }
        cell.setOccupied(false);
        cell.setHead(false);
        CarParams carParams = cell.getCarParams();
        int oldX = (int) carParams.xPosition;
        int currentSpeed = (int) carParams.getParameter(RequestConstants.CURRENT_SPEED_REQUEST);
        MyLogger.log("Moving car from position " + oldX + " to " + (oldX + currentSpeed) +
                " with speed " + currentSpeed, Constants.DEBUG_FOR_LOGGING);
        Cell newCellOfHead = cells[carParams.lane][(int) (carParams.xPosition + currentSpeed)];
        carParams.xPosition = carParams.xPosition + currentSpeed; // update position of the car head
        newCellOfHead.setOccupied(true); // occupy the new cell of the car head
        newCellOfHead.setHead(true);
        newCellOfHead.setCarParams(carParams);
        for (int i = 1; i < carParams.getParameter(RequestConstants.LENGTH_REQUEST); i++) { // move the rest of the car
            if (oldX - i >= 0) {
                // clear the old cells behind the car
                cells[carParams.lane][oldX - i].setOccupied(false);
                cells[carParams.lane][oldX - i].setCarParams(null);
                // occupy the new cells behind the car
                if ((int) carParams.xPosition - i >= 0) {
                    cells[carParams.lane][(int) carParams.xPosition - i].setOccupied(true);
                    cells[carParams.lane][(int) carParams.xPosition - i].setCarParams(carParams);
                }
            }
        }
    }

    /**
     * function to get road-dependent parameters for a car, such as distances to other cars
     *
     * @param parameters HashMap to store the retrieved parameters
     * @param param String representing the parameter to be retrieved
     * @param car CarParams of the car for which the parameters are to be retrieved
     **/
    private void getRoadDependedParameters(HashMap<String, Double> parameters, String param, CarParams car) {
        int lane = car.lane;
        int position = (int) car.xPosition;
        int nextCarPos;
        int prevCarPos;

        switch (param) { // getting parameters for model

            case RequestConstants.CURRENT_SPEED_REQUEST:   // current speed of vehicle
                parameters.put(RequestConstants.CURRENT_SPEED_REQUEST, car.getParameter(RequestConstants.
                        CURRENT_SPEED_REQUEST));
                break;

            case RequestConstants.DISTANCE_TO_NEXT_CAR_REQUEST:   // distance to next car in the same lane
                nextCarPos = getNextOccupiedCell(lane, position, Direction.STRAIGHT);
                if (nextCarPos == Constants.NO_CAR_IN_FRONT) {
                    parameters.put(RequestConstants.DISTANCE_TO_NEXT_CAR_REQUEST, Double.MAX_VALUE);
                } else {
                    parameters.put(RequestConstants.DISTANCE_TO_NEXT_CAR_REQUEST, (double) (nextCarPos - position - 1));
                }
                break;

            case RequestConstants.DISTANCE_TO_NEXT_CAR_LEFT_REQUEST:   // distance to next car in the left lane
                nextCarPos = getNextOccupiedCell(lane, position, Direction.LEFT);
                if (nextCarPos == Constants.NO_CAR_IN_FRONT) {
                    parameters.put(RequestConstants.DISTANCE_TO_NEXT_CAR_LEFT_REQUEST,
                            Double.MAX_VALUE);
                } else if (nextCarPos == Constants.NO_LANE_THERE) {
                    parameters.put(RequestConstants.DISTANCE_TO_NEXT_CAR_LEFT_REQUEST,
                            Constants.PARAMETER_UNDEFINED);
                } else {
                    parameters.put(RequestConstants.DISTANCE_TO_NEXT_CAR_LEFT_REQUEST,
                            (double) (nextCarPos - position - 1));
                }
                break;

            case RequestConstants.DISTANCE_TO_NEXT_CAR_RIGHT_REQUEST:    // distance to next car in the right lane
                nextCarPos = getNextOccupiedCell(lane, position, Direction.RIGHT);
                if (nextCarPos == Constants.NO_CAR_IN_FRONT) {
                    parameters.put(RequestConstants.DISTANCE_TO_NEXT_CAR_RIGHT_REQUEST,
                            Double.MAX_VALUE);
                } else if (nextCarPos == Constants.NO_LANE_THERE) {
                    parameters.put(RequestConstants.DISTANCE_TO_NEXT_CAR_RIGHT_REQUEST,
                            Constants.PARAMETER_UNDEFINED);
                } else {
                    parameters.put(RequestConstants.DISTANCE_TO_NEXT_CAR_RIGHT_REQUEST,
                            (double) (nextCarPos - position - 1));
                }
                break;

            case RequestConstants.DISTANCE_TO_PREVIOUS_CAR_REQUEST: // distance to previous car in the same lane
                prevCarPos = getPreviousOccupiedCell(lane, position, Direction.STRAIGHT);
                if (prevCarPos == Constants.NO_CAR_IN_FRONT) {
                    parameters.put(RequestConstants.DISTANCE_TO_PREVIOUS_CAR_REQUEST,
                            (double) (position + 1));
                } else {
                    parameters.put(RequestConstants.DISTANCE_TO_PREVIOUS_CAR_REQUEST,
                            (double) (position - prevCarPos - 1));
                }
                break;

            case RequestConstants.DISTANCE_TO_PREVIOUS_CAR_LEFT_REQUEST:  // distance to previous car in the left lane
                prevCarPos = getPreviousOccupiedCell(lane, position, Direction.LEFT);
                if (prevCarPos == Constants.NO_CAR_IN_FRONT) {
                    parameters.put(RequestConstants.DISTANCE_TO_PREVIOUS_CAR_LEFT_REQUEST, (double) (position + 1));
                } else if (prevCarPos == Constants.NO_LANE_THERE) {
                    parameters.put(RequestConstants.DISTANCE_TO_PREVIOUS_CAR_LEFT_REQUEST,
                            (double) Constants.NO_LANE_THERE);
                } else {
                    parameters.put(RequestConstants.DISTANCE_TO_PREVIOUS_CAR_LEFT_REQUEST,
                            (double) (position - prevCarPos - 1));
                }
                break;

            case RequestConstants.DISTANCE_TO_PREVIOUS_CAR_RIGHT_REQUEST: // distance to previous car in the right lane
                prevCarPos = getPreviousOccupiedCell(lane, position, Direction.RIGHT);
                if (prevCarPos == Constants.NO_CAR_IN_FRONT) {
                    parameters.put(RequestConstants.DISTANCE_TO_PREVIOUS_CAR_RIGHT_REQUEST,
                            (double) (position + 1));
                } else if (prevCarPos == Constants.NO_LANE_THERE) {
                    parameters.put(RequestConstants.DISTANCE_TO_PREVIOUS_CAR_RIGHT_REQUEST,
                            (double) Constants.NO_LANE_THERE);
                } else {
                    parameters.put(RequestConstants.DISTANCE_TO_PREVIOUS_CAR_RIGHT_REQUEST,
                            (double) (position - prevCarPos - 1));
                }
                break;

            default:
                MyLogger.log("Unknown parameter requested: " + param, Constants.DEBUG_FOR_LOGGING);
        }
    }

    /**
     * function to get all requested parameters for a car at a given lane and position
     *
     * @param lane lane number of the car
     * @param position position of the car on the road
     * @param requestedParameters String of requested parameters separated by Constants.REQUEST_SEPARATOR
     * @return HashMap of requested parameters with their values
     **/
    private HashMap<String, Double> getParameters(int lane, int position, String requestedParameters) {
        HashMap<String, Double> parameters = new HashMap<>();
        String[] params = requestedParameters.split(RequestConstants.REQUEST_SEPARATOR);
        if (params.length == 0) {
            MyLogger.log("No parameters requested", Constants.DEBUG_FOR_LOGGING);
            return null;
        }
        String[] carGeneratedParams = this.generator.getCarGenerationParameters();

        CarParams car = this.cells[lane][position].getCarParams();
        for (String param : params) {
            if (StringEditor.isInArray(carGeneratedParams, param)) { // get parameters from car that is being inspected
                parameters.put(param, car.getParameter(param));
            } else {
                this.getRoadDependedParameters(parameters, param, car);
            }
        }
        return parameters;
    }

    /**
     * get index of lane where to look for info based on direction, like next of previous occupied cell
     *
     * @param lane lane number of the car
     * @param direction Direction enum representing the direction to check (LEFT, RIGHT, STRAIGHT)
     * @return int lane number to look for info, or Constants.NO_LANE_THERE if no lane is there in that direction
     **/
    private int getLaneForInfo(int lane, Direction direction) {
        if (direction == Direction.LEFT) {
            if (lane > 0) {
                return lane - 1;
            } else {
                return Constants.NO_LANE_THERE;
            }
        } else if (direction == Direction.RIGHT) {
            if (lane < numberOfLanes - 1) {
                return lane + 1;
            } else {
                return Constants.NO_LANE_THERE;
            }
        }

        return lane; // STRAIGHT
    }

    /**
     * function to get the position of the previous occupied cell in a given lane and direction
     *
     * @param lane lane number of the car
     * @param position position of the car on the road
     * @param direction Direction enum representing the direction to check (LEFT, RIGHT, STRAIGHT)
     * @return int position of the previous occupied cell, or Constants.NO_CAR_IN_FRONT if none found,
     *         or Constants.NO_LANE_THERE if lane change is not possible
     **/
    private int getPreviousOccupiedCell(int lane, int position, Direction direction) {
        int laneNew = getLaneForInfo(lane, direction);
        if (laneNew == Constants.NO_LANE_THERE) {
            return Constants.NO_LANE_THERE;
        }

        for (int pos = position - 1; pos >= 0; pos--) {
            if (cells[laneNew][pos].isOccupied()) {
                return pos;
            }
        }
        return Constants.NO_CAR_IN_FRONT;
    }

    /**
     * function to get the position of the next occupied cell in a given lane and direction
     *
     * @param lane lane number of the car
     * @param position position of the car on the road
     * @param direction Direction enum representing the direction to check (LEFT, RIGHT, STRAIGHT)
     * @return int position of the next occupied cell, or Constants.NO_CAR_IN_FRONT if none found,
     *         or Constants.NO_LANE_THERE if lane change is not possible
     **/
    private int getNextOccupiedCell(int lane, int position, Direction direction) {
        int laneNew = getLaneForInfo(lane, direction);
        if (laneNew == Constants.NO_LANE_THERE) {
            return Constants.NO_LANE_THERE;
        }

        for (int pos = position + 1; pos < this.numberOfCells; pos++) {
            if (cells[laneNew][pos].isOccupied()) {
                return pos;
            }
        }
        return Constants.NO_CAR_IN_FRONT;
    }

    /**
     * debug function to print the road state to console, occupied cells are represented by 'X', unoccupied by 'O'
     **/
    public void debugPrintRoad() {
        for (int lane = 0; lane < numberOfLanes; lane++) {
            for (int position = 0; position < this.numberOfCells; position++) {
                System.out.print(cells[lane][position].isOccupied() ? "X" : "O");
            }
            System.out.println();
        }
    }

    /**
     * function to remove a car from the road at a specified position and lane
     *
     * @param lane lane number where the car is to be removed
     * @param position position on the road where the head of the car is located
     **/
    private void removeCar(int lane, int position) {
        if (lane < 0 || lane >= numberOfLanes || position < 0 || position >= numberOfCells) {
            MyLogger.log("Invalid lane or position to remove car", Constants.DEBUG_FOR_LOGGING);
            return;
        }
        if (!cells[lane][position].isOccupied() || !cells[lane][position].isHead()) {
            MyLogger.log("No car head at the specified position to remove", Constants.DEBUG_FOR_LOGGING);
            return;
        }
        CarParams carParams = cells[lane][position].getCarParams();
        for (int i = 0; i < carParams.getParameter(RequestConstants.LENGTH_REQUEST); i++) {
            int posToClear = (int) (carParams.xPosition - i);
            if (posToClear >= 0 && posToClear < numberOfCells) {
                cells[lane][posToClear].setOccupied(false);
                cells[lane][posToClear].setHead(false);
                cells[lane][posToClear].setCarParams(null);
            }
        }
    }

    /**
     * function to get the content of the road, i.e., the cells array
     *
     * @return 2D array of Cell objects representing the road content
     **/
    @Override
    public Cell[][] getContent() {
        return cells;
    }

    /**
     * function to place a car on the road at a specified position and lane
     *
     * @param car CarParams of the car to be placed
     * @param x position on the road where the head of the car is to be placed
     * @param lane lane number where the car is to be placed
     **/
    private void placeCar(CarParams car, int x, int lane) {
        if (lane < 0 || lane >= numberOfLanes || x < 0 || x >= numberOfCells) {
            MyLogger.log("Invalid lane or position to place car", Constants.DEBUG_FOR_LOGGING);
            return;
        }
        for (int i = 0; i < car.getParameter(RequestConstants.LENGTH_REQUEST); i++) {
            int posToOccupy = x - i;
            if (posToOccupy >= 0 && posToOccupy < numberOfCells) {
                cells[lane][posToOccupy].setOccupied(true);
                cells[lane][posToOccupy].setCarParams(car);
                if (i == 0) {
                    cells[lane][posToOccupy].setHead(true);
                    car.xPosition = x;
                    car.lane = lane;
                } else {
                    cells[lane][posToOccupy].setHead(false);
                }
            } else {
                MyLogger.log("Car length exceeds road boundaries or is negative during placing car",
                        Constants.DEBUG_FOR_LOGGING);
            }
        }
    }

    /**
     * function to check if a car is still relevant on the road, i.e., if it has not completely passed the end of the
     * road
     *
     * @param car CarParams of the car to be checked
     * @param newSpeed new speed of the car
     * @return true if the car is still relevant, false otherwise
     **/
    private boolean checkIfCarStillRelevant(CarParams car, int newSpeed) {
        if (car == null) {
            return false;
        }

        if ((car.xPosition + newSpeed - car.getParameter(RequestConstants.LENGTH_REQUEST) + 1) >= this.numberOfCells) { // fuck zero base indexing
            removeCar(car.lane, (int) car.xPosition);
            return false;
        }

        return true;
    }

    /**
     *
     **/
    private boolean isCarAtEnd(CarParams car, int newSpeed) {
        if (car == null) { // sanity check
            return false;
        }

        return (car.xPosition + newSpeed) >= this.numberOfCells;
    }

    /**
     * moves car head to the body cell in case it would be out of the road but the rest of the cars body would still be
     * on the road
     *
     * @param car cars which head is supposed to be moved
     * @param newSpeed int value of speed which moved head of the car out of the road
     **/
    private void moveCarHead(CarParams car, int newSpeed) {
        if (car == null) {
            return;
        }

        int oldX = (int) car.xPosition;
        int howMuchOverflow = (int) (car.xPosition + newSpeed - this.numberOfCells + 1);

        for (int i = 0; i < howMuchOverflow; i++) {
            int posToClear = oldX - i;
            if (posToClear >= 0 && posToClear < this.numberOfCells) {
                cells[car.lane][posToClear].setOccupied(false);
                cells[car.lane][posToClear].setHead(false);
                cells[car.lane][posToClear].setCarParams(null);
            }
        }

        int newHeadX = oldX - howMuchOverflow;
        car.setParameter(RequestConstants.LENGTH_REQUEST, car.getParameter(RequestConstants.LENGTH_REQUEST)
                - howMuchOverflow);

        cells[car.lane][newHeadX].setOccupied(true);
        cells[car.lane][newHeadX].setHead(true);
        cells[car.lane][newHeadX].setCarParams(car);
        car.setParameter(RequestConstants.CURRENT_SPEED_REQUEST, newSpeed);
        car.xPosition = newHeadX;

        MyLogger.log("Old head position: " + oldX, Constants.DEBUG_FOR_LOGGING);
        MyLogger.log("Car at lane " + car.lane + " reached the end of the road and is partially removed.",
                Constants.DEBUG_FOR_LOGGING);
        MyLogger.log("New head position: " + newHeadX + ", New length: " +
                car.getParameter(RequestConstants.LENGTH_REQUEST) + ", Current speed: " +
                car.getParameter(RequestConstants.CURRENT_SPEED_REQUEST), Constants.DEBUG_FOR_LOGGING);
        this.moveCar(cells[car.lane][newHeadX]);
    }

    /**
     * function to attempt a lane change for a car in a given cell
     *
     * @param cell Cell representing the head of the car attempting to change lanes
     * @return Direction enum representing the desired direction of lane change (LEFT, RIGHT, STRAIGHT)
     **/
    private Direction attemptLaneChange(Cell cell) {
        String requestParameters = AppContext.LANE_CHANGING_MODEL.requestParameters();
        HashMap<String, Double> parameters = getParameters(cell.getCarParams().lane,
                (int) cell.getCarParams().xPosition, requestParameters);
        if (parameters == null) {
            MyLogger.log("Error getting parameters for lane change for car at lane " +
                    cell.getCarParams().lane + ", position " + (int) cell.getCarParams().xPosition,
                    Constants.ERROR_FOR_LOGGING);
            return null;
        }

        Direction desiredDirection = AppContext.LANE_CHANGING_MODEL.changeLaneIfDesired(parameters);

        if (desiredDirection == Direction.LEFT) {
            int currentLane = cell.getCarParams().lane;
            if (currentLane > 0) {
                return Direction.LEFT;
            }
        } else if (desiredDirection == Direction.RIGHT) {
            int currentLane = cell.getCarParams().lane;
            if (currentLane < numberOfLanes - 1) {
                return Direction.RIGHT;
            }
        }

        return Direction.STRAIGHT;
    }

    /**
     * Function to get the number of cars currently on the road
     *
     * @return number of cars on the road
     **/
    @Override
    public int getNumberOfCarsOnRoad() {
        int carCount = 0;
        for (int lane = 0; lane < numberOfLanes; lane++) {
            for (int position = 0; position < this.numberOfCells; position++) {
                if (cells[lane][position].isOccupied() && cells[lane][position].isHead()) {
                    carCount++;
                }
            }
        }
        return carCount;
    }

    /**
     * Function to get the length of the road in cells
     *
     * @return length of the road in cells
     **/
    public double getLengthInCells() {
        return this.numberOfCells;
    }

    /***
     * Function to get the size of each cell in meters
     *
     * @return size of each cell in meters
     **/
    public double getCellSize() {
        return this.cellSize;
    }

    /*******************************
     * Class to represent the result of a lane change attempt, including the direction and car parameters
     *
     * @author Michael Hladky
     * @version 1.0
     *******************************/
    private static class LaneChangeResult {

        /** direction of the lane change **/
        public Direction direction;

        /** car parameters of the car attempting to change lanes **/
        public CarParams carParams;

        /**
         * Constructor for LaneChangeResult
         *
         * @param direction direction of the lane change
         * @param carParams car parameters of the car attempting to change lanes
         **/
        public LaneChangeResult(Direction direction, CarParams carParams) {
            this.direction = direction;
            this.carParams = carParams;
        }
    }
}
